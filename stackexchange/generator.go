package stackexchange

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"net/http"
	"os"
	"text/template"
	"time"
)

var exists = struct{}{}

func writeDictionary() error {
	pages := 10
	pageSize := 100

	// Temporary, for detecting duplicates
	tagcheck := make(map[string]struct{})

	// Used in the template below
	data := struct {
		Tags     []string
		Synonyms map[string]string
	}{
		Tags:     make([]string, 0),
		Synonyms: make(map[string]string),
	}

	for _, site := range sites {
		for page := 1; page <= pages; page++ {
			wrapper, err := fetchTags(page, pageSize, site)
			if err != nil {
				return err
			}

			// Avoid duplicates; since we are querying multiple sites, duplication is common.
			for _, item := range wrapper.Items {
				if item.Moderator {
					// We don't want those
					continue
				}

				// Only append tags if they haven't been added already
				if _, found := tagcheck[item.Name]; !found {
					tagcheck[item.Name] = exists
					data.Tags = append(data.Tags, item.Name)
				}

				// Only add synonyms if they haven't been added already
				for _, key := range item.Synonyms {
					if _, found := data.Synonyms[key]; !found {
						data.Synonyms[key] = item.Name
					}
					// What if the same synonym points to multiple canonical tags?
					// The above logic just uses the first one, maybe that's ok.
				}
			}

			if !wrapper.HasMore {
				break
			}
		}
	}

	tmpl := `
// This file is generated by github.com/clipperhouse/jargon/stackexchange/generator.go
// Best not to modify it, as it will likely be overwritten
package stackexchange

type dict struct {
	tags []string
	synonyms map[string]string
}

func (d *dict) GetTags() []string {
	return d.tags
}

func (d *dict) GetSynonyms() map[string]string {
	return d.synonyms
}

// Dictionary is the main exported Dictionary of Stack Exchange tags and synonyms, fetched via api.stackexchange.com
// It includes the most popular {{ .Tags | len }} tags and their synonyms
var Dictionary = &dict{tags, synonyms}

var tags = {{printf "%#v" .Tags}}

var synonyms = {{printf "%#v" .Synonyms}}
	
`
	t := template.Must(template.New("dict").Parse(tmpl))

	var source bytes.Buffer
	tmplErr := t.Execute(&source, data)
	if tmplErr != nil {
		return tmplErr
	}

	formatted, fmtErr := format.Source(source.Bytes())

	if fmtErr != nil {
		return fmtErr
	}

	f, createErr := os.Create("generated.go")
	if createErr != nil {
		return createErr
	}
	defer f.Close()

	_, writeErr := f.Write(formatted)

	if writeErr != nil {
		return writeErr
	}

	return nil
}

var sites = []string{"stackoverflow", "serverfault"}
var tagsURL = "http://api.stackexchange.com/2.2/tags?page=%d&pagesize=%d&order=desc&sort=popular&site=%s&filter=!4-J-du8hXSkh2Is1a&page=%d"
var client = http.Client{
	Timeout: time.Second * 2, // Maximum of 2 secs
}
var empty = wrapper{}

func fetchTags(page, pageSize int, site string) (wrapper, error) {
	if page == 0 {
		page = 1
	}

	if pageSize == 0 {
		pageSize = 100
	}

	url := fmt.Sprintf(tagsURL, page, pageSize, site)
	r, httpErr := client.Get(url)
	if httpErr != nil {
		return empty, httpErr
	}

	defer r.Body.Close()

	body, readErr := ioutil.ReadAll(r.Body)
	if readErr != nil {
		return empty, readErr
	}

	wrapper := wrapper{}
	jsonErr := json.Unmarshal(body, &wrapper)
	if jsonErr != nil {
		return empty, jsonErr
	}

	return wrapper, nil
}

type item struct {
	Name      string   `json:"name"`
	Synonyms  []string `json:"synonyms"`
	Moderator bool     `json:"is_moderator_only"`
}

type wrapper struct {
	Items   []item `json:"items"`
	HasMore bool   `json:"has_more"`
}
